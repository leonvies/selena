<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Subway Runner 3D - Side Scroller Medieval</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #d4af37;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 10;
        }
        #score { font-size: clamp(20px, 4vw, 32px); font-weight: bold; }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 30px;
            border: 3px solid #d4af37;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 20;
            width: 60%;
            max-width: 400px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
        }
        button {
            background: #d4af37;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 15px;
            box-shadow: 0 4px 0 #997a1a;
        }
        button:active { transform: translateY(2px); box-shadow: 0 2px 0 #997a1a; }

        #loading {
            position: absolute;
            width: 100%;
            height: 100%;
            background: #fff;
            color: #d4af37;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="loading">
            <div>A preparar a jornada...</div>
            <div style="font-size: 10px; margin-top: 10px; opacity: 0.6;">A carregar modelos 3D...</div>
        </div>

        <div id="ui-layer">
            <div id="score">Ouro: 0</div>
        </div>

        <div id="game-over">
            <h1>FIM DA ESTRADA!</h1>
            <p id="final-score">Ouro acumulado: 0</p>
            <button id="restart-btn">RECOMEÇAR</button>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "fflate": "https://cdn.jsdelivr.net/npm/fflate@0.8.0/lib/browser.module.js"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        let scene, camera, renderer, clock;
        let player, mixer, ground;
        let obstacles = [];
        let sceneries = []; 
        let score = 0;
        let gameActive = true;
        
        const CONSTANT_SPEED = 0.55;
        let speed = CONSTANT_SPEED; 
        const BASE_SPEED = 0.4;
        const LANE_WIDTH = 1.8; 
        const LANES = [LANE_WIDTH, 0, -LANE_WIDTH]; 
        let currentLane = 1; 
        const PLAYER_X = -6; 
        let isJumping = false;
        let jumpVelocity = 0;
        const GRAVITY = -0.025; 
        const JUMP_FORCE = 0.45; 

        const container = document.getElementById('game-container');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

            camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(-3.5, 3.5, 10.5); 
            camera.lookAt(-2, 1, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x8d5b28, 0.5);
            scene.add(hemiLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(-10, 20, 10);
            sunLight.castShadow = true;
            scene.add(sunLight);

            createEnvironment();
            loadPlayer();
            
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('restart-btn').onclick = resetGame;
            setupControls();
            
            animate();
        }

        function loadPlayer() {
            const manager = new THREE.LoadingManager();
            manager.setURLModifier((url) => {
                if (url.includes('mixamo') || url.includes('.fbm/')) {
                    return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
                }
                return url;
            });

            const fbxLoader = new FBXLoader(manager);
            const playerUrl = 'https://raw.githubusercontent.com/leonvies/run/main/Runningwoman.fbx';
            const bagUrl = 'https://raw.githubusercontent.com/leonvies/run/main/bag.fbx';

            fbxLoader.load(playerUrl, (object) => {
                player = object;
                player.scale.set(0.012, 0.012, 0.012); 
                player.position.set(PLAYER_X, 0, LANES[currentLane]);
                player.rotation.y = Math.PI / 2;
                
                player.traverse(node => {
                    if (node.isMesh) {
                        node.castShadow = true; node.receiveShadow = true;
                        if (node.material) { node.material.color.set(0xdddddd); node.material.side = THREE.DoubleSide; }
                    }
                });

                fbxLoader.load(bagUrl, (bag) => {
                    bag.scale.set(1.0, 1.0, 1.0); 
                    bag.traverse(node => { if (node.isMesh) { node.castShadow = true; node.receiveShadow = true; } });

                    let backBone = null;
                    player.traverse(child => {
                        if (child.isBone && (child.name.toLowerCase().includes('spine2') || child.name.toLowerCase().includes('chest'))) {
                            backBone = child;
                        }
                    });

                    if (backBone) {
                        backBone.add(bag);

                        // POSIÇÃO FINAL DEFINIDA
                        const posX = 0;   
                        const posY = 10;  
                        const posZ = -55; 
                        
                        bag.position.set(posX, posY, posZ);

                        // ROTAÇÃO FINAL DEFINIDA PELO UTILIZADOR
                        const rotX = -Math.PI / 2; 
                        const rotY = 0;
                        const rotZ = 2; // Valor confirmado como correto

                        bag.rotation.set(rotX, rotY, rotZ);

                    } else {
                        player.add(bag);
                        bag.position.set(0, 130, -50);
                    }

                    scene.add(player);
                    mixer = new THREE.AnimationMixer(player);
                    if (player.animations && player.animations.length > 0) mixer.clipAction(player.animations[0]).play();
                    
                    const loadingEl = document.getElementById('loading');
                    if (loadingEl) loadingEl.style.display = 'none';
                    
                    spawnObstacle();
                    spawnScenery();
                });
            });
        }

        function createEnvironment() {
            const groundGeo = new THREE.PlaneGeometry(2000, 15);
            const groundMat = new THREE.MeshPhongMaterial({ color: 0xbc9b7a }); 
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            for (let i = 0; i < 3; i++) {
                const railGeo = new THREE.PlaneGeometry(2000, 0.1);
                const railMat = new THREE.MeshBasicMaterial({ color: 0x887766 });
                const rail = new THREE.Mesh(railGeo, railMat);
                rail.rotation.x = -Math.PI / 2;
                rail.position.set(0, 0.02, LANES[i]);
                scene.add(rail);
            }
        }

        function spawnScenery() {
            if (!gameActive || !player) return;
            const type = Math.random();
            let sceneryObj;
            if (type > 0.6) {
                const geometry = new THREE.CylinderGeometry(2.5, 3, 18, 8);
                const material = new THREE.MeshPhongMaterial({ color: 0xe0e0e0 });
                sceneryObj = new THREE.Mesh(geometry, material);
                sceneryObj.position.set(40, 9, -10);
                const roofGeo = new THREE.ConeGeometry(3.5, 6, 4);
                const roof = new THREE.Mesh(roofGeo, new THREE.MeshPhongMaterial({color: 0xaa4444}));
                roof.position.y = 12;
                sceneryObj.add(roof);
            } else {
                const geometry = new THREE.BoxGeometry(10, 8, 4);
                const material = new THREE.MeshPhongMaterial({ color: 0xd0d0d0 });
                sceneryObj = new THREE.Mesh(geometry, material);
                sceneryObj.position.set(40, 4, -12);
            }
            sceneryObj.castShadow = true; sceneryObj.receiveShadow = true;
            scene.add(sceneryObj);
            sceneries.push(sceneryObj);
            setTimeout(spawnScenery, 2000 / (speed * 1.5));
        }

        function spawnObstacle() {
            if (!gameActive || !player) return;
            const laneIndex = 0; 
            const type = Math.random();
            let obstacle;
            if (type > 0.4) {
                const geometry = new THREE.BoxGeometry(3, 2.5, 1.3);
                const material = new THREE.MeshPhongMaterial({ color: 0xffeeaa }); 
                obstacle = new THREE.Mesh(geometry, material);
                obstacle.userData = { type: 'block', lane: laneIndex };
                obstacle.position.set(40, 1.25, LANES[laneIndex]);
            } else {
                const geometry = new THREE.BoxGeometry(0.6, 0.8, 1.5);
                const material = new THREE.MeshPhongMaterial({ color: 0x8b4513 }); 
                obstacle = new THREE.Mesh(geometry, material);
                obstacle.userData = { type: 'barrier', lane: laneIndex };
                obstacle.position.set(40, 0.4, LANES[laneIndex]);
            }
            obstacle.castShadow = true;
            scene.add(obstacle);
            obstacles.push(obstacle);
            setTimeout(spawnObstacle, Math.max(600, 2000 - (speed * 1800)));
        }

        function setupControls() {
            window.addEventListener('keydown', (e) => {
                if (!gameActive) return;
                if (e.key === 'ArrowUp') moveLane(1); 
                if (e.key === 'ArrowDown') moveLane(-1); 
                if (e.key === 'ArrowRight' || e.key === ' ') jump();
            });
        }

        function moveLane(dir) {
            let nextLane = currentLane + dir;
            if (nextLane >= 1 && nextLane <= 2) currentLane = nextLane;
        }

        function jump() {
            if (!isJumping) { isJumping = true; jumpVelocity = JUMP_FORCE; }
        }

        function updatePlayer() {
            if (!player) return;
            const targetZ = LANES[currentLane];
            player.position.z += (targetZ - player.position.z) * 0.15;
            if (isJumping) {
                player.position.y += jumpVelocity;
                jumpVelocity += GRAVITY;
                if (player.position.y <= 0) { player.position.y = 0; isJumping = false; jumpVelocity = 0; }
            }
        }

        function animate() {
            if (!gameActive) return;
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (mixer) {
                mixer.update(delta * 1.5);
                if (player) {
                    player.position.x = PLAYER_X;
                    player.traverse(child => {
                        if (child.isBone && (child.name.toLowerCase().includes('hips') || child.name.toLowerCase().includes('pelvis'))) {
                            child.position.x = 0; child.position.z = 0;
                        }
                    });
                }
            }
            updatePlayer();
            for (let i = sceneries.length - 1; i >= 0; i--) {
                const scn = sceneries[i]; scn.position.x -= speed;
                if (scn.position.x < -30) { scene.remove(scn); sceneries.splice(i, 1); }
            }
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i]; obs.position.x -= speed;
                if (obs.position.x < -20) {
                    scene.remove(obs); obstacles.splice(i, 1); score += 10;
                    document.getElementById('score').innerText = `Ouro: ${score}`;
                }
            }
            renderer.render(scene, camera);
        }

        function resetGame() {
            obstacles.forEach(obs => scene.remove(obs));
            sceneries.forEach(scn => scene.remove(scn));
            obstacles = []; sceneries = []; score = 0;
            speed = CONSTANT_SPEED; currentLane = 1; gameActive = true; isJumping = false;
            if (player) player.position.set(PLAYER_X, 0, LANES[currentLane]);
            document.getElementById('score').innerText = `Ouro: 0`;
            document.getElementById('game-over').style.display = 'none';
            animate(); spawnObstacle(); spawnScenery();
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        init();
    </script>
</body>
</html>
