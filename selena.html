<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Kodular - Audio Fix Edition</title>
    <!-- Bibliotecas Necessárias -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        /* =========================================
           CONFIGURAÇÃO DE TEMA E ANIMAÇÕES
           ========================================= */
        :root {
            --bg-custom: url('wp4281782.jpg'); 
            --board-opacity: 0.5;
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        @keyframes dust-puff {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            50% { opacity: 0.5; }
            100% { transform: translateY(-20px) scale(1.5); opacity: 0; }
        }

        @keyframes rotate-flash {
            0% { filter: brightness(1); transform: scale(1); }
            50% { filter: brightness(2); transform: scale(1.05); }
            100% { filter: brightness(1); transform: scale(1); }
        }

        .shake-active { animation: shake 0.1s infinite; }
        .piece-rotate-effect { animation: rotate-flash 0.15s ease-out; }

        .dust-particle {
            position: absolute;
            bottom: 0;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            pointer-events: none;
            animation: dust-puff 0.4s ease-out forwards;
        }

        body { 
            background: #020617; 
            background-image: var(--bg-custom);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-repeat: no-repeat;
            overscroll-behavior-y: contain; 
            position: fixed; 
            width: 100%; height: 100%;
            margin: 0; padding: 0;
            overflow: hidden;
            font-family: sans-serif;
        }

        body::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), rgba(0,0,0,0.9));
            z-index: -1;
            pointer-events: none;
        }

        * { -webkit-tap-highlight-color: transparent; }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr);
            gap: 1px;
            background-color: rgba(15, 23, 42, var(--board-opacity));
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            position: relative;
        }

        .bezel-metal {
            background: rgba(15, 23, 42, 0.92);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
        }

        .btn-3d-rotate {
            background: linear-gradient(145deg, #991b1b, #450a0a);
            border: 4px solid #1f2937;
            box-shadow: 0 12px 0 #1a0505, 0 15px 25px rgba(0,0,0,0.7), inset 0 4px 6px rgba(255,255,255,0.2);
            transition: all 0.05s ease-out;
            position: relative; top: 0;
        }

        .btn-3d-rotate:active:not(:disabled) {
            top: 10px;
            box-shadow: 0 2px 0 #1a0505, 0 5px 15px rgba(0,0,0,0.5);
        }

        .bolt-btn {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(251, 191, 36, 0.3);
            transition: all 0.2s;
        }
        .bolt-btn:active:not(:disabled) {
            transform: scale(0.9);
            background: rgba(251, 191, 36, 0.2);
        }
        .bolt-btn:disabled {
            opacity: 0.3;
            filter: grayscale(1);
        }
    </style>
</head>
<body>
    <div id="root" style="position: relative; z-index: 10;"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef, useMemo } = React;

        // =========================================
        // SISTEMA DE ÁUDIO REFINADO
        // =========================================
        const sounds = {
            music: new Audio("https://ia800504.us.archive.org/33/items/TetrisThemeMusic/Tetris.mp3"),
            rotate: new Audio("https://www.soundjay.com/mechanical/sounds/camera-shutter-click-01.mp3"),
            move: new Audio("https://www.soundjay.com/buttons/sounds/button-09.mp3"),
            impact: new Audio("https://www.soundjay.com/transportation/sounds/trunk-close-1.mp3"),
            clear: new Audio("https://www.soundjay.com/buttons/sounds/button-10.mp3"),
            lightning: new Audio("https://www.soundjay.com/nature/sounds/thunder-01.mp3"),
            curse: new Audio("https://www.soundjay.com/misc/sounds/evil-laugh-01.mp3"),
            gameover: new Audio("https://www.soundjay.com/human/sounds/shout-01.mp3")
        };

        // Configurações base
        sounds.music.loop = true;
        sounds.music.volume = 0.2;
        Object.keys(sounds).forEach(key => {
            if (key !== 'music') sounds[key].volume = 0.8; // Volume alto para FX
        });

        // Função para desbloquear áudio no primeiro toque (Browser Policy)
        let audioUnlocked = false;
        const unlockAudio = () => {
            if (audioUnlocked) return;
            Object.values(sounds).forEach(s => {
                s.play().then(() => {
                    s.pause();
                    s.currentTime = 0;
                }).catch(() => {});
            });
            audioUnlocked = true;
        };

        const playSound = (name) => {
            try {
                const s = sounds[name];
                if (s) {
                    s.currentTime = 0;
                    s.play().catch(e => console.error("Erro áudio:", name, e));
                }
            } catch (e) {}
        };

        const signalKodular = (msg) => {
            try {
                if (window.AppInventor && window.AppInventor.setWebViewString) {
                    window.AppInventor.setWebViewString(msg + ":" + Date.now());
                }
            } catch (e) {}
        };

        const COLS = 10;
        const ROWS = 20;
        const INITIAL_SPEED = 800;
        const FAST_SPEED = 50; 

        const TETROMINOS = {
            I: { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: 'bg-cyan-400 border-cyan-200 shadow-[0_0_10px_rgba(34,211,238,0.8)]' },
            J: { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: 'bg-blue-500 border-blue-300 shadow-[0_0_10px_rgba(59,130,246,0.8)]' },
            L: { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: 'bg-orange-500 border-orange-300 shadow-[0_0_10px_rgba(249,115,22,0.8)]' },
            O: { shape: [[1, 1], [1, 1]], color: 'bg-yellow-400 border-yellow-200 shadow-[0_0_10px_rgba(250,204,21,0.8)]' },
            S: { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: 'bg-green-400 border-green-200 shadow-[0_0_10px_rgba(74,222,128,0.8)]' },
            T: { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: 'bg-purple-500 border-purple-300 shadow-[0_0_10px_rgba(168,85,247,0.8)]' },
            Z: { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: 'bg-red-500 border-red-300 shadow-[0_0_10px_rgba(239,68,68,0.8)]' },
            BLACK: { shape: [[1, 1, 1], [1, 1, 1], [1, 1, 1]], color: 'bg-black border-slate-700 shadow-[0_0_15px_rgba(255,255,255,0.2)]', isBlack: true }
        };

        function App() {
            const [board, setBoard] = useState(Array.from({ length: ROWS }, () => Array(COLS).fill(null)));
            const [activePiece, setActivePiece] = useState(null);
            const [nextPiece, setNextPiece] = useState(null);
            const [score, setScore] = useState(0);
            const [gameOver, setGameOver] = useState(false);
            const [paused, setPaused] = useState(false);
            const [isFastDropping, setIsFastDropping] = useState(false);
            const [isShaking, setIsShaking] = useState(false);
            const [isRotating, setIsRotating] = useState(false);
            const [dustParticles, setDustParticles] = useState([]);
            const [isMuted, setIsMuted] = useState(false);
            
            const [lightnings, setLightnings] = useState(3);
            const [countdown, setCountdown] = useState(null);
            const [nextIsCurse, setNextIsCurse] = useState(false);

            const bagRef = useRef([]);
            const boardRef = useRef(board);
            const activePieceRef = useRef(activePiece);
            const nextPieceRef = useRef(nextPiece);

            useEffect(() => { boardRef.current = board; }, [board]);
            useEffect(() => { activePieceRef.current = activePiece; }, [activePiece]);
            useEffect(() => { nextPieceRef.current = nextPiece; }, [nextPiece]);

            // Controle da música (Silêncio apenas na música)
            useEffect(() => {
                sounds.music.volume = isMuted ? 0 : 0.2;
            }, [isMuted]);

            useEffect(() => {
                let timer;
                if (countdown !== null && countdown > 0 && !paused && !gameOver) {
                    timer = setInterval(() => setCountdown(prev => prev - 1), 1000);
                } else if (countdown === 0 && !gameOver) {
                    setNextIsCurse(true);
                    setCountdown(30);
                    signalKodular("curse_activated");
                }
                return () => clearInterval(timer);
            }, [countdown, paused, gameOver]);

            const triggerImpactVFX = (posX) => {
                const newParticles = Array.from({ length: 6 }).map((_, i) => ({
                    id: Math.random(),
                    left: `${posX * 10 + (Math.random() * 10)}%`
                }));
                setDustParticles(prev => [...prev, ...newParticles]);
                setTimeout(() => {
                    setDustParticles(prev => prev.filter(p => !newParticles.find(n => n.id === p.id)));
                }, 400);
                setIsShaking(true);
                setTimeout(() => setIsShaking(false), 150);
                playSound('impact'); // Som de peso garantido no impacto
            };

            const getNextFromBag = useCallback(() => {
                if (nextIsCurse) {
                    setNextIsCurse(false);
                    playSound('curse');
                    return { ...TETROMINOS.BLACK, pos: { x: 3, y: 0 } };
                }
                if (bagRef.current.length === 0) {
                    const keys = Object.keys(TETROMINOS).filter(k => k !== 'BLACK');
                    const newBag = [...keys].sort(() => Math.random() - 0.5);
                    bagRef.current = newBag;
                }
                const type = bagRef.current.pop();
                return { ...TETROMINOS[type], pos: { x: 3, y: 0 } };
            }, [nextIsCurse]);

            const checkCollision = (piece, pos, currentBoard) => {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const ny = pos.y + y;
                            const nx = pos.x + x;
                            if (nx < 0 || nx >= COLS || ny >= ROWS || (ny >= 0 && currentBoard[ny][nx])) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            };

            const rotate = () => {
                unlockAudio(); // Libera áudio no primeiro uso
                if (!activePiece || paused || gameOver || activePiece.isBlack) return;
                const s = activePiece.shape;
                const rotated = s[0].map((_, i) => s.map(row => row[i]).reverse());
                if (!checkCollision({ ...activePiece, shape: rotated }, activePiece.pos, boardRef.current)) {
                    setActivePiece(prev => ({ ...prev, shape: rotated }));
                    setIsRotating(true);
                    setTimeout(() => setIsRotating(false), 100);
                    playSound('rotate');
                    signalKodular("rotate");
                }
            };

            const move = (dir) => {
                unlockAudio();
                if (!activePiece || paused || gameOver || activePiece.isBlack) return;
                const np = { ...activePiece.pos, x: activePiece.pos.x + dir };
                if (!checkCollision(activePiece, np, boardRef.current)) {
                    setActivePiece(prev => ({ ...prev, pos: np }));
                    playSound('move'); // Efeito sonoro lateral "voop"
                    signalKodular("move");
                }
            };

            const lock = () => {
                const currentPiece = activePieceRef.current;
                const currentBoard = boardRef.current;
                if (!currentPiece) return;

                const newBoard = currentBoard.map(r => [...r]);
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((v, x) => {
                        if (v) {
                            const by = currentPiece.pos.y + y;
                            const bx = currentPiece.pos.x + x;
                            if (by >= 0) newBoard[by][bx] = currentPiece.color;
                        }
                    });
                });

                triggerImpactVFX(currentPiece.pos.x);

                let linesCleared = 0;
                const filtered = newBoard.filter(r => !r.every(c => c !== null));
                linesCleared = ROWS - filtered.length;

                while (filtered.length < ROWS) {
                    filtered.unshift(Array(COLS).fill(null));
                }

                if (linesCleared > 0) {
                    setScore(prev => prev + (linesCleared * 100));
                    if (countdown !== null) setCountdown(30);
                    playSound('clear');
                    signalKodular("clear");
                }

                setBoard(filtered);
                
                const next = nextPieceRef.current;
                if (checkCollision(next, next.pos, filtered)) {
                    setGameOver(true);
                    setActivePiece(null);
                    sounds.music.pause();
                    playSound('gameover');
                    signalKodular("gameover");
                } else {
                    setActivePiece(next);
                    setNextPiece(getNextFromBag());
                }
            };

            const drop = useCallback(() => {
                const currentPiece = activePieceRef.current;
                if (!currentPiece || paused || gameOver) return;

                const np = { ...currentPiece.pos, y: currentPiece.pos.y + 1 };
                if (!checkCollision(currentPiece, np, boardRef.current)) {
                    setActivePiece(prev => ({ ...prev, pos: np }));
                } else {
                    lock();
                }
            }, [paused, gameOver, getNextFromBag]);

            const useLightning = (e) => {
                e.stopPropagation();
                unlockAudio();
                if (lightnings <= 0 || paused || gameOver) return;
                setIsShaking(true);
                setTimeout(() => setIsShaking(false), 3000);
                
                const currentCount = lightnings;
                let linesToClear = (currentCount === 3) ? 2 : (currentCount === 2) ? 4 : 6;
                
                setBoard(current => {
                    const newBoard = current.slice(0, ROWS - linesToClear);
                    while (newBoard.length < ROWS) newBoard.unshift(Array(COLS).fill(null));
                    return newBoard;
                });

                setLightnings(prev => prev - 1);
                playSound('lightning');
                signalKodular("lightning");
                if (currentCount === 1) setCountdown(30);
            };

            const startGame = () => {
                unlockAudio();
                if (!isMuted) {
                    sounds.music.currentTime = 0;
                    sounds.music.play().catch(() => {});
                }
                
                signalKodular("start");
                bagRef.current = [];
                setNextIsCurse(false);
                setBoard(Array.from({ length: ROWS }, () => Array(COLS).fill(null)));
                setScore(0);
                setGameOver(false);
                setPaused(false);
                setLightnings(3);
                setCountdown(null);
                const first = { ...TETROMINOS.T, pos: { x: 3, y: 0 } };
                setActivePiece(first);
                setNextPiece(getNextFromBag());
            };

            const togglePause = () => {
                unlockAudio();
                const newPaused = !paused;
                setPaused(newPaused);
                if (newPaused) sounds.music.pause(); 
                else if (!isMuted) sounds.music.play().catch(() => {});
                signalKodular(newPaused ? "pause" : "resume");
            };

            const toggleMute = (e) => {
                e.stopPropagation();
                unlockAudio();
                setIsMuted(!isMuted);
            };

            useEffect(() => {
                let interval;
                if (!paused && !gameOver && activePiece) {
                    const speed = (isFastDropping && !activePiece.isBlack) 
                        ? FAST_SPEED 
                        : Math.max(100, INITIAL_SPEED - (Math.floor(score/500) * 50));
                    interval = setInterval(drop, speed);
                }
                return () => clearInterval(interval);
            }, [paused, gameOver, activePiece, drop, score, isFastDropping]);

            const display = useMemo(() => {
                const b = board.map(r => [...r]);
                if (activePiece && !paused) {
                    activePiece.shape.forEach((row, y) => {
                        row.forEach((v, x) => {
                            if (v) {
                                const by = activePiece.pos.y + y;
                                const bx = activePiece.pos.x + x;
                                if (by >= 0 && by < ROWS) b[by][bx] = activePiece.color;
                            }
                        });
                    });
                }
                return b;
            }, [board, activePiece, paused]);

            return (
                <div 
                    className={`fixed inset-0 flex flex-col font-sans overflow-hidden touch-none select-none ${isShaking ? 'shake-active' : ''}`}
                    onPointerDown={(e) => { 
                        unlockAudio(); 
                        if (!activePiece?.isBlack) setIsFastDropping(true); 
                    }}
                    onPointerUp={() => setIsFastDropping(false)}
                    onPointerLeave={() => setIsFastDropping(false)}
                >
                    {/* Header */}
                    <div className="flex items-center justify-between px-4 h-16 bezel-metal z-40">
                        <div className="flex flex-col">
                            <span className="font-black text-2xl tracking-tighter text-slate-100 italic leading-none">TETRIS</span>
                            <span className="text-[9px] text-blue-500 font-bold uppercase tracking-widest leading-none mt-1">Audio Fix</span>
                        </div>
                        
                        <div className="flex flex-col items-center justify-center">
                            <span className="text-[8px] text-slate-400 font-bold uppercase mb-1">Próxima</span>
                            <div className="next-piece-container">
                                {nextPiece && nextPiece.shape.map((row, y) => (
                                    <div key={y} className="flex gap-0.5">
                                        {row.map((cell, x) => (
                                            <div key={x} className={`w-2.5 h-2.5 rounded-[1px] ${cell ? nextPiece.color : 'bg-transparent'}`} />
                                        ))}
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="flex items-center gap-2">
                            {/* Silencia APENAS a música */}
                            <button onPointerDown={toggleMute} className={`p-2 rounded-xl border border-slate-700/50 transition-all ${isMuted ? 'bg-red-900/40 text-red-500' : 'bg-slate-800 text-blue-400'}`}>
                                {isMuted ? <i data-lucide="headphones-off" size="18"></i> : <i data-lucide="headphones" size="18"></i>}
                            </button>
                            
                            <button onPointerDown={(e) => { e.stopPropagation(); togglePause(); }} className="p-2 bezel-metal rounded-xl text-blue-400 active:scale-95 transition">
                                {paused ? <i data-lucide="play" fill="currentColor"></i> : <i data-lucide="pause" fill="currentColor"></i>}
                            </button>
                            <div className="flex flex-col items-end">
                                <span className="text-[9px] text-slate-500 font-bold uppercase leading-none mb-1">Almas</span>
                                <span className="font-mono text-lg font-bold text-slate-100 leading-none">{score.toString().padStart(5, '0')}</span>
                            </div>
                        </div>
                    </div>

                    {/* Jogo */}
                    <div className="flex-1 flex items-center justify-center relative p-4 z-20">
                        <div className="relative rounded-xl overflow-hidden shadow-[0_0_50px_rgba(0,0,0,0.9)]" style={{ height: '62vh', aspectRatio: '1/2' }}>
                            <div className="h-full w-full game-grid">
                                {display.map((row, y) => row.map((cell, x) => {
                                    const isActivePart = activePiece && !paused && y >= activePiece.pos.y && y < activePiece.pos.y + activePiece.shape.length && x >= activePiece.pos.x && x < activePiece.pos.x + activePiece.shape[0].length && activePiece.shape[y - activePiece.pos.y][x - activePiece.pos.x];
                                    return (
                                        <div key={`${y}-${x}`} className={`w-full h-full ${cell || 'bg-transparent'} rounded-[1px] ${cell ? `${cell} border-b border-r border-black/50 brightness-125` : 'border-[0.5px] border-white/5'} ${isActivePart && isRotating ? 'piece-rotate-effect' : ''}`} />
                                    );
                                }))}
                                {dustParticles.map(p => <div key={p.id} className="dust-particle" style={{ left: p.left }} />)}
                            </div>

                            {countdown !== null && (
                                <div className="absolute top-4 left-0 right-0 text-center z-50 pointer-events-none">
                                    <div className="bg-red-950/80 text-red-500 text-[10px] font-black py-1 px-4 rounded-md border border-red-900 animate-pulse uppercase">
                                        Maldição em: {countdown}S
                                    </div>
                                </div>
                            )}

                            {(!activePiece || gameOver) && (
                                <div className="absolute inset-0 bg-slate-950/95 flex flex-col items-center justify-center p-6 text-center z-30" onPointerDown={(e) => e.stopPropagation()}>
                                    {gameOver && (
                                        <div className="mb-10">
                                            <h2 className="text-red-700 font-black text-5xl mb-2 italic tracking-tighter drop-shadow-xl">VOCÊ MORREU</h2>
                                            <p className="text-slate-500 font-mono text-xs tracking-widest uppercase">Score: {score}</p>
                                        </div>
                                    )}
                                    <button onPointerDown={startGame} className="bg-red-900 hover:bg-red-800 px-14 py-5 rounded-2xl font-black text-2xl text-white active:scale-90 transition-all shadow-[0_0_30px_rgba(153,27,27,0.5)] border border-red-700 uppercase">
                                        {gameOver ? 'Renascer' : 'Iniciar'}
                                    </button>
                                </div>
                            )}
                        </div>

                        <div className="absolute right-1 flex flex-col gap-4 z-40" onPointerDown={(e) => e.stopPropagation()}>
                            {[...Array(3)].map((_, i) => (
                                <button key={i} disabled={lightnings <= i || gameOver || paused} onPointerDown={useLightning} className="bolt-btn w-12 h-12 rounded-2xl flex items-center justify-center shadow-2xl border-t border-yellow-500/20">
                                    <i data-lucide="zap" fill={lightnings > i ? "#eab308" : "none"} className={lightnings > i ? "text-yellow-500" : "text-slate-800"}></i>
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Botões 3D */}
                    <div className="h-40 bezel-metal grid grid-cols-3 items-center px-4 z-40 pb-6" onPointerDown={(e) => e.stopPropagation()}>
                        <div className="flex justify-center">
                            <button disabled={activePiece?.isBlack} onPointerDown={() => move(-1)} className="w-20 h-20 bezel-metal rounded-2xl flex items-center justify-center text-slate-100 active:bg-blue-900/40 disabled:opacity-10 shadow-xl">
                                <i data-lucide="chevron-left" size="44"></i>
                            </button>
                        </div>
                        <div className="flex justify-center">
                            <button disabled={activePiece?.isBlack} onPointerDown={rotate} className="w-24 h-24 btn-3d-rotate rounded-full flex items-center justify-center text-white disabled:opacity-10 shadow-2xl">
                                <i data-lucide="rotate-cw" size="48"></i>
                            </button>
                        </div>
                        <div className="flex justify-center">
                            <button disabled={activePiece?.isBlack} onPointerDown={() => move(1)} className="w-20 h-20 bezel-metal rounded-2xl flex items-center justify-center text-slate-100 active:bg-blue-900/40 disabled:opacity-10 shadow-xl">
                                <i data-lucide="chevron-right" size="44"></i>
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        setTimeout(() => { if (window.lucide) window.lucide.createIcons(); }, 500);
    </script>
</body>
</html>
